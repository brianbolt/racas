% Generated by roxygen2 (4.0.2): do not edit by hand
\docType{class}
\name{Messenger}
\alias{Messenger}
\alias{messenger}
\title{Messenger}
\usage{
messenger(racas = TRUE, envir = parent.frame(), ...)
}
\value{
A json object with the sessionid among a number of html divs to display back to the user
}
\description{
Reference class object to allow passing of messages
}
\details{
The racasMessenger (called with \code{messenger}) should be reset at the
beginning of rApache routes and by utility functions that are called by
node.js. Prefix these utility functions with "\code{external.}" Other
functions should not reset the racasMessenger, but can define their own local
Messenger objects.
}
\examples{
#Basic Messenger
myMessenger <- Messenger$new(envir = environment())

#Racas Messenger
#This special messenger is stored within the racas environment and can be passed in and out of functions
#To retrieve the racas messenger
racasMessenger <- messenger()
#To reset the messenger
racasMessenger <- messenger()$reset()

#Adding messages
myMessenger <- Messenger$new(envir = environment())
myMessenger$addError("myerror")
myMessenger$addWarning("mywarning")
myMessenger$addInfo("mywarning")
myMessenger$addUserError("my user error")
myMessenger$addUserWarning("my user warning")
myMessenger$addUserInfo("my user info")

#Running and capture output using messenger
myMessenger <- Messenger$new(envir = environment())

#This is run like normal
myMessenger$capture_output({test <- 1+1})
test

or

myMessenger$capture_output('test <- 1+1')
test

or

myMessenger$capture_output({test <- 1; test <- 1+test})

#This captures the error
myMessenger <- Messenger$new(envir = environment())
test <- function() stop("there is an error!")
myMessenger$capture_output("test()")
myMessenger$errors

#Capturing a user error on run
myMessenger <- Messenger$new(envir = environment())
test <- function() stop("there is an error!")
myMessenger$capture_output("test()", userError = "There was an error running test function")
myMessenger$errors
myMessenger$userErrors

#stopOnError = TRUE will throw error if error occurs
myMessenger <- Messenger$new()
myMessenger$devMode <-  FALSE
test <- function() stop("there is an error!")
myMessenger$capture_output({test()}, stopOnError = TRUE, userError = "some sort of error to return to user")
myMessenger$errors
myMessenger$userErrors

#devMode bypassses logic and just evaluate's the given expression
myMessenger <- Messenger$new()
myMessenger$devMode <-  TRUE
test <- function() stop("there is an error!")
myMessenger$capture_output('{test()}')
myMessenger$errors

#Adding a user error within a capture_output Call (use racas messenger)
racasMessenger <- messenger()$reset()
test <- function() {
 racasMessenger <- messenger()
 e <- try(stop("there is an error!"), silent = TRUE)
 if(class(e)=="try-error") {
   racasMessenger$addUserError("Inner error")
   #note, you have to throw and error for the outer userError to be added
   stop("some error")
 }
 return(1)
}
racasMessenger$capture_output("answer <- test()", userError = "Outer error")
racasMessenger$userErrors

# At the top of an rApache file
globalMessenger <- messenger()
globalMessenger$reset()
globalMessenger$logger <- logger(logName = "com.acas.name.of.big.module", reset=TRUE)

# An R function that is called by node.js
external.runBigModule <- function(request) {
  globalMessenger <- messenger()
  globalMessenger$reset()
  globalMessenger$logger <- logger(logName = "com.acas.name.of.big.module", reset=TRUE)
}

# While coding interactively, the logger can be changed to log to console
globalMessenger <- messenger()
globalMessenger$logger <- createLogger(logName = "com.acas.name.of.big.module", logToConsole=TRUE)
}

